<html>
  <head>
    <script src="/rtl/jquery.js"></script>
    <script>
       $(function() {
           var s;
           function print(txt) {
               $("#console").append(txt+"\n");
               window.scrollTo(0, document.body.scrollHeight);
           };
           var host = "<?lsp=response:encoderedirecturl(request:url(),true):gsub("^http","ws")?>";
           try { s = new WebSocket(host); } catch(e) {}
           if( ! s ) {
               print("WebSocket not supported");
               return;
           }
           s.onopen = function() {
               print("WebSocket connected. Waiting for server...");
           };
           s.onmessage = function (e) {
               if(e.data instanceof Blob) {
                   var f = new FileReader();
                   f.onload = function(e) { print(e.target.result) };
                   f.readAsText(e.data);                   
               }
               else {
                   print(e.data);
               }
           };
       });
    </script>
  </head>
  <body>
  <pre id="console"></pre>
  </body>
</html>
<?lsp

--   ***********     Server side Lua code:   **************

local mqttClients={} -- key = mqtt client instance
local msgCnt=0

-- Shuffles (randomizes) the allBrokers list and returns a table with
-- 25 selected brokers.
local function shuffle(allBrokers)
   for i = #allBrokers, 2, -1 do
      local j = ba.rnd(1,i)
      allBrokers[i], allBrokers[j] = allBrokers[j], allBrokers[i]
   end
   local cnt=0
   local selectedBrokers={} -- key = ip address
   for i = 1, #allBrokers do
      local ip = allBrokers[i]
      if not selectedBrokers[ip] then
         selectedBrokers[ip]=true
         cnt=cnt+1
         if cnt > 24 then break end
      end
   end
   return selectedBrokers
end

-- Prints MQTT topic and payload data. The function closes all MQTT
-- connections when the number of received messages > 100
local function onpub(info, msg)
   msgCnt=msgCnt+1
   if msgCnt > 100 or
      not ws:write(tostring(msgCnt)..": "..info,true) or
      (#msg > 0 and not ws:write(msg))
   then
      ws:write("We are done!",true)
      for mqtt in pairs(mqttClients) do mqtt:disconnect() end
   end
end

 -- This function connects to one MQTT client and subscribes to "#"
local function startMQTT(ip)
   ws:write("Connecting: "..ip,true)
   local mqtt=require"mqttc".create(ip,
      function(type,code,status) -- onstatus
         if "mqtt" == type and "connect" == code and 0 == status.reasoncode then
            ws:write(ip.." connected",true)
            return true
         end
      end,
      function(topic,msg) -- onpub
         onpub(string.format("%s: %s",ip,topic), msg)
      end)
   mqtt:subscribe("#") -- Subscribe to all messages exchanged via the broker
   mqttClients[mqtt]=true
end

if request:header"Sec-WebSocket-Key" then -- If a WebSocket request
   ws = ba.socket.req2sock(request) -- Upgrade to a WebSocket connection
   if ws then
      ws:event(function() while ws:read() do end end, "s")
      ba.thread.run(function()
         ws:write("Downloading brokers.txt", true)
         local http=require"httpc".create()
         local ok,err=http:request{url="https://realtimelogic.info/brokers.txt"}
         if ok then
            local data,err=http:read"*a"
            if data then
               local allBrokers = {}
               -- Extract all IP addresses from the received data
               for ip in data:gmatch"(.-)\r?\n" do table.insert(allBrokers,ip) end
               local selectedBrokers = shuffle(allBrokers)
               for ip in pairs(selectedBrokers) do startMQTT(ip) end
            else
               ws:write("Cannot download brokers.txt",true)
            end
         else
            ws:write("HTTP err: "..err,true)
         end
      end)
   end
   return -- Done
end
response:setheader("x-xss-protection","1; mode=block")
response:setheader("content-security-policy",
"default-src 'self'; connect-src http: https: ws: wss:; script-src 'self' 'unsafe-inline'")
response:setheader("x-frame-options","SAMEORIGIN")
response:setheader("x-content-type","nosniff")
?>
